substitutions:
  device_name: well_water_system
  friendly_name: "Well Water System"
  
esphome:
  name: ${device_name}
  platform: ESP32
  board: esp32dev

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  ap:
    ssid: "${device_name} Fallback"
    password: !secret ap_password

logger:
  level: INFO  # Set to DEBUG during initial setup to see DS18B20 addresses and raw values
               # Return to INFO or WARN for production to reduce log volume

api:
  encryption:
    key: !secret api_encryption_key

ota:
  password: !secret ota_password

web_server:
  port: 80

# I2C for ADS1115 pressure sensor ADC
i2c:
  sda: GPIO21
  scl: GPIO22
  scan: true
  id: i2c_bus

# 1-Wire for DS18B20 temperature sensors
one_wire:
  - platform: gpio
    pin: GPIO22

# ============================================
# SENSORS
# ============================================

sensor:
  # ------------------------------
  # FLOW MONITORING
  # ------------------------------
  - platform: pulse_meter
    pin: GPIO21
    name: "${friendly_name} Flow Rate"
    id: water_flow_rate
    unit_of_measurement: "L/min"
    device_class: water
    state_class: measurement
    icon: "mdi:water"
    accuracy_decimals: 2
    internal_filter: 100ms
    timeout: 30s
    filters:
      # YF-B10: 660 pulses/liter
      # L/min = (60 sec/min) / 660 pulses/L = 0.0909
      - multiply: 0.0909
      
    total:
      name: "${friendly_name} Total Volume"
      id: water_total_liters
      unit_of_measurement: "L"
      device_class: water
      state_class: total_increasing
      accuracy_decimals: 1
      icon: "mdi:gauge"

  # Convert to cubic meters for Energy Dashboard
  - platform: template
    name: "${friendly_name} Total m³"
    id: water_total_m3
    unit_of_measurement: "m³"
    device_class: water
    state_class: total_increasing
    accuracy_decimals: 3
    lambda: return id(water_total_liters).state * 0.001;
    update_interval: 60s
    
  # Convert to gallons
  - platform: template
    name: "${friendly_name} Total Gallons"
    id: water_total_gallons
    unit_of_measurement: "gal"
    device_class: water
    state_class: total_increasing
    accuracy_decimals: 1
    lambda: return id(water_total_liters).state * 0.264172;
    update_interval: 60s

  # ------------------------------
  # PRESSURE MONITORING (via ADS1115)
  # ------------------------------
  - platform: ads1115
    id: ads1115_hub
    address: 0x48
    
  - platform: ads1115
    name: "${friendly_name} Pump Output Pressure"
    id: pump_output_pressure
    ads1115_id: ads1115_hub
    multiplexer: 'A0'
    gain: 4.096
    unit_of_measurement: "PSI"
    device_class: pressure
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 2s
    filters:
      # Sensor: 0.5V = 0 PSI, 4.5V = 100 PSI
      - calibrate_linear:
          - 0.5 -> 0
          - 4.5 -> 100
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1
          
  - platform: ads1115
    name: "${friendly_name} System Pressure"
    id: system_pressure
    ads1115_id: ads1115_hub
    multiplexer: 'A1'
    gain: 4.096
    unit_of_measurement: "PSI"
    device_class: pressure
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 2s
    filters:
      - calibrate_linear:
          - 0.5 -> 0
          - 4.5 -> 100
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1
          
  - platform: ads1115
    name: "${friendly_name} Filtered Pressure"
    id: filter_outlet_pressure
    ads1115_id: ads1115_hub
    multiplexer: 'A2'
    gain: 4.096
    unit_of_measurement: "PSI"
    device_class: pressure
    state_class: measurement
    accuracy_decimals: 1
    update_interval: 2s
    filters:
      - calibrate_linear:
          - 0.5 -> 0
          - 4.5 -> 100
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1
  
  # Calculated filter pressure drop
  - platform: template
    name: "${friendly_name} Filter Pressure Drop"
    id: filter_pressure_drop
    unit_of_measurement: "PSI"
    device_class: pressure
    state_class: measurement
    accuracy_decimals: 1
    lambda: |-
      return id(system_pressure).state - id(filter_outlet_pressure).state;
    update_interval: 5s

  # ------------------------------
  # TEMPERATURE MONITORING
  # ------------------------------
  - platform: dallas_temp
    address: 0x1c0000031edd2a28  # Replace with actual address from logs
    name: "${friendly_name} Incoming Water Temp"
    id: incoming_water_temp
    unit_of_measurement: "°F"
    accuracy_decimals: 1
    filters:
      - lambda: return x * (9.0/5.0) + 32.0;  # C to F
      
  - platform: dallas_temp
    address: 0x1d0000031f0e5c28  # Replace with actual address from logs
    name: "${friendly_name} Hot Water Temp"
    id: hot_water_temp
    unit_of_measurement: "°F"
    accuracy_decimals: 1
    filters:
      - lambda: return x * (9.0/5.0) + 32.0;  # C to F
      
  # Water heater temperature rise
  - platform: template
    name: "${friendly_name} Heater Temp Rise"
    id: temp_rise
    unit_of_measurement: "°F"
    accuracy_decimals: 1
    lambda: |-
      return id(hot_water_temp).state - id(incoming_water_temp).state;
    update_interval: 30s

  # ------------------------------
  # WATER QUALITY MONITORING
  # ------------------------------
  - platform: adc
    pin: GPIO34
    name: "${friendly_name} TDS"
    id: water_tds
    attenuation: 11db
    unit_of_measurement: "ppm"
    accuracy_decimals: 0
    update_interval: 10s
    filters:
      # Calibrate based on your specific TDS sensor
      # Typical range: 0-3.3V = 0-1000ppm
      - calibrate_linear:
          - 0.0 -> 0
          - 3.3 -> 1000
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1

  - platform: adc
    pin: GPIO35
    name: "${friendly_name} pH"
    id: water_ph
    attenuation: 11db
    unit_of_measurement: "pH"
    accuracy_decimals: 1
    update_interval: 10s
    filters:
      # Calibrate with pH 4.0 and 7.0 buffer solutions
      # Measure voltage at each pH and update these values
      - calibrate_linear:
          - 0.5 -> 4.0
          - 2.0 -> 7.0
      - sliding_window_moving_average:
          window_size: 10
          send_every: 1

  # ------------------------------
  # PUMP MONITORING
  # ------------------------------
  - platform: ct_clamp
    sensor: pump_adc_sensor
    name: "${friendly_name} Pump Current"
    id: pump_current
    update_interval: 1s
    filters:
      # Calibrate for your pump's actual amperage
      - calibrate_linear:
          - 0 -> 0
          - 0.5 -> 4.8  # Adjust based on pump rating
    
  - platform: adc
    id: pump_adc_sensor
    pin: GPIO33
    attenuation: 11db
    
  # Pump cycle and runtime tracking
  - platform: template
    name: "${friendly_name} Pump Cycles Today"
    id: pump_cycles_today
    accuracy_decimals: 0
    lambda: 'return id(pump_start_count);'
    update_interval: 60s
    
  - platform: template
    name: "${friendly_name} Pump Total Runtime Hours"
    id: pump_runtime_hours
    unit_of_measurement: "h"
    accuracy_decimals: 1
    lambda: 'return id(total_pump_runtime) / 3600000.0;'
    update_interval: 60s
    
  - platform: template
    name: "${friendly_name} Gallons Per Pump Cycle"
    id: gallons_per_cycle
    unit_of_measurement: "gal"
    accuracy_decimals: 1
    lambda: |-
      static float last_total = 0;
      static bool last_pump_state = false;
      
      bool pump_on = id(pump_running).state;
      float current_total = id(water_total_gallons).state;
      
      if (!last_pump_state && pump_on) {
        float gallons_used = current_total - last_total;
        last_total = current_total;
        last_pump_state = true;
        return gallons_used;
      } else if (last_pump_state && !pump_on) {
        last_pump_state = false;
      }
      
      return id(gallons_per_cycle).state;
    update_interval: 2s

  # WiFi signal
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    update_interval: 60s

  # Uptime
  - platform: uptime
    name: "${friendly_name} Uptime"
    update_interval: 60s

# ============================================
# BINARY SENSORS
# ============================================

binary_sensor:
  # ------------------------------
  # PHYSICAL CONTROL PANEL
  # ------------------------------
  - platform: gpio
    pin:
      number: GPIO15
      mode: INPUT_PULLUP
      inverted: true
    name: "${friendly_name} Manual Mode"
    id: manual_mode_switch
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_press:
      - logger.log: "Switched to MANUAL mode"
    on_release:
      - logger.log: "Switched to AUTO mode"
      
  - platform: gpio
    pin:
      number: GPIO14
      mode: INPUT_PULLUP
      inverted: true
    name: "${friendly_name} Manual Open Button"
    id: manual_open_button
    internal: true  # Don't expose to HA
    filters:
      - delayed_on: 50ms
    on_press:
      - if:
          condition:
            binary_sensor.is_on: manual_mode_switch
          then:
            - switch.turn_on: main_valve
            - logger.log: "Manual OPEN command"
          else:
            - logger.log: "Ignoring button - system in AUTO mode"
          
  - platform: gpio
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
      inverted: true
    name: "${friendly_name} Manual Close Button"
    id: manual_close_button
    internal: true
    filters:
      - delayed_on: 50ms
    on_press:
      - if:
          condition:
            binary_sensor.is_on: manual_mode_switch
          then:
            - switch.turn_off: main_valve
            - logger.log: "Manual CLOSE command"
          else:
            - logger.log: "Ignoring button - system in AUTO mode"

  # ------------------------------
  # LEAK DETECTION
  # ------------------------------
  - platform: gpio
    pin:
      number: GPIO26
      mode: INPUT_PULLUP
      inverted: true
    name: "${friendly_name} Mechanical Room Leak"
    id: leak_sensor
    device_class: moisture
    filters:
      - delayed_on: 500ms
    on_press:
      then:
        # Close valve immediately
        - switch.turn_off: main_valve
        - logger.log:
            level: ERROR
            format: "LEAK DETECTED - Valve closed"
        # Wait for current pump cycle to complete
        - delay: 30s
        # Disable pump interlock
        - switch.turn_off: pump_interlock_relay
        - logger.log:
            level: ERROR
            format: "Pump disabled due to leak"

  # ------------------------------
  # PUMP MONITORING
  # ------------------------------
  - platform: template
    name: "${friendly_name} Pump Running"
    id: pump_running
    lambda: |-
      return id(pump_current).state > 1.0;  # Adjust threshold
    on_press:
      then:
        - globals.set:
            id: pump_start_count
            value: !lambda 'return id(pump_start_count) + 1;'
        - globals.set:
            id: last_pump_start
            value: !lambda 'return millis();'
    on_release:
      then:
        - globals.set:
            id: total_pump_runtime
            value: !lambda 'return id(total_pump_runtime) + (millis() - id(last_pump_start));'

  # Alert: Filter needs replacement (only when low/no flow)
  - platform: template
    name: "${friendly_name} Filter Replacement Needed"
    id: filter_clogged
    device_class: problem
    lambda: |-
      // Only alert if high pressure drop during low/no flow
      // During high flow, pressure drop is normal
      float drop = id(filter_pressure_drop).state;
      float flow = id(water_flow_rate).state;
      
      // If flow < 2 L/min and pressure drop > 15 PSI, filter likely clogged
      return (flow < 2.0 && drop > 15.0);
    update_interval: 10s

  # Alert: Scalding risk
  - platform: template
    name: "${friendly_name} Scalding Risk"
    device_class: problem
    lambda: |-
      return id(hot_water_temp).state > 125.0;

  # Alert: High TDS
  - platform: template
    name: "${friendly_name} High TDS Alert"
    device_class: problem
    lambda: |-
      return id(water_tds).state > 500;

  # Alert: pH out of range
  - platform: template
    name: "${friendly_name} pH Out of Range"
    device_class: problem
    lambda: |-
      float ph = id(water_ph).state;
      return ph < 6.5 || ph > 8.5;

  # Alert: Pressure tank waterlogged (multiple short cycles)
  - platform: template
    name: "${friendly_name} Pressure Tank Issue"
    device_class: problem
    lambda: |-
      // Track short cycles over time instead of alerting on single occurrence
      float gallons = id(gallons_per_cycle).state;
      
      // Reset counter daily
      if (millis() - id(short_cycle_reset_time) > 86400000) {
        id(short_cycle_count) = 0;
        id(short_cycle_reset_time) = millis();
      }
      
      // Increment counter for short cycles
      if (gallons < 1.0 && gallons > 0.1) {
        id(short_cycle_count) = id(short_cycle_count) + 1;
      }
      
      // Alert if more than 5 short cycles in 24 hours
      return id(short_cycle_count) > 5;
    update_interval: 60s

  # Alert: Low pump output (with time delay to avoid transients)
  - platform: template
    name: "${friendly_name} Low Pump Pressure"
    device_class: problem
    lambda: |-
      static unsigned long low_pressure_start = 0;
      bool pump_on = id(pump_running).state;
      float pressure = id(pump_output_pressure).state;
      
      if (pump_on && pressure < 40.0) {
        if (low_pressure_start == 0) low_pressure_start = millis();
        // Alert only if low pressure persists for 10+ seconds
        return (millis() - low_pressure_start) > 10000;
      } else {
        low_pressure_start = 0;
        return false;
      }
    update_interval: 5s

  # Alert: Continuous high flow (alert only, doesn't close valve)
  - platform: template
    name: "${friendly_name} Continuous Flow Alert"
    id: continuous_flow_alert
    device_class: problem
    lambda: |-
      float flow = id(water_flow_rate).state;
      
      if (flow > 5.0) {
        if (id(continuous_flow_start) == 0) {
          id(continuous_flow_start) = millis();
        }
        // Alert after 30 minutes of continuous flow > 5 L/min
        return (millis() - id(continuous_flow_start)) > 1800000;
      } else {
        id(continuous_flow_start) = 0;
        return false;
      }
    update_interval: 60s

  # Connection status
  - platform: status
    name: "${friendly_name} Status"

# ============================================
# SWITCHES
# ============================================

switch:
  # ------------------------------
  # MAIN WATER VALVE CONTROL
  # ------------------------------
  - platform: gpio
    pin: GPIO25
    name: "${friendly_name} Main Valve"
    id: main_valve
    icon: "mdi:pipe-valve"
    restore_mode: RESTORE_DEFAULT_OFF  # Fail-safe: closed on boot
    
    on_turn_on:
      # Safety interlock: prevent opening if leak detected
      - if:
          condition:
            binary_sensor.is_on: leak_sensor
          then:
            - switch.turn_off: main_valve
            - logger.log:
                level: ERROR
                format: "Cannot open valve - leak still detected!"
          else:
            - delay: 5s
            - switch.turn_on: pump_interlock_relay  # Enable pump
            - logger.log: "Valve opened, pump enabled"
    
    on_turn_off:
      - delay: 5s
      - switch.turn_off: pump_interlock_relay  # Disable pump
      - logger.log: "Valve closed, pump disabled"

  # ------------------------------
  # PUMP INTERLOCK RELAY
  # ------------------------------
  - platform: gpio
    pin: GPIO27
    name: "${friendly_name} Pump Interlock"
    id: pump_interlock_relay
    restore_mode: RESTORE_DEFAULT_OFF  # Pump disabled on boot (fail-safe)
    icon: "mdi:pump"
    on_turn_on:
      - logger.log: "Pump interlock released - pump can run"
    on_turn_off:
      - logger.log: "Pump interlock engaged - pump disabled"

# ============================================
# GLOBAL VARIABLES
# ============================================

globals:
  - id: pump_start_count
    type: int
    restore_value: yes
    initial_value: '0'
    
  - id: total_pump_runtime
    type: unsigned long
    restore_value: yes
    initial_value: '0'
    
  - id: last_pump_start
    type: unsigned long
    restore_value: no
    initial_value: '0'
    
  - id: continuous_flow_start
    type: unsigned long
    restore_value: no
    initial_value: '0'
    
  - id: short_cycle_count
    type: int
    restore_value: no
    initial_value: '0'
    
  - id: short_cycle_reset_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

# ============================================
# TIME & AUTOMATIONS
# ============================================

time:
  - platform: homeassistant
    id: homeassistant_time
    # Reset daily pump cycle counter at midnight
    on_time:
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - globals.set:
              id: pump_start_count
              value: '0'

# Monitoring automation (logging only, no auto-shutoff)
interval:
  - interval: 60s
    then:
      - lambda: |-
          // This just logs high flow for debugging
          // Actual alerting is handled by continuous_flow_alert binary sensor
          float flow = id(water_flow_rate).state;
          
          if (flow > 5.0 && (millis() - id(continuous_flow_start)) > 1800000) {
            ESP_LOGW("automation", "High continuous flow detected for 30+ minutes: %.1f L/min", flow);
            ESP_LOGW("automation", "Check continuous_flow_alert sensor and create HA automation for notifications");
          }

  # ------------------------------
  # STATUS LED UPDATES
  # ------------------------------
  - interval: 500ms
    then:
      - lambda: |-
          // Update valve status LEDs
          if (id(main_valve).state) {
            id(valve_open_led).turn_on();
            id(valve_closed_led).turn_off();
          } else {
            id(valve_open_led).turn_off();
            id(valve_closed_led).turn_on();
          }
          
          // Update pump enabled LED
          if (id(pump_interlock_relay).state) {
            id(pump_enabled_led).turn_on();
          } else {
            id(pump_enabled_led).turn_off();
          }
          
          // Update leak alert LED (blink if active)
          static bool blink_state = false;
          if (id(leak_sensor).state) {
            blink_state = !blink_state;
            if (blink_state) {
              id(leak_alert_led).turn_on();
            } else {
              id(leak_alert_led).turn_off();
            }
          } else {
            id(leak_alert_led).turn_off();
          }

# ============================================
# SERVICES (callable from Home Assistant)
# ============================================

api:
  services:
    # Reset water meter total
    - service: reset_water_total
      variables:
        new_total: float
      then:
        - pulse_meter.set_total_pulses:
            id: water_flow_rate
            value: !lambda 'return new_total * 660;'  # Convert L to pulses
        - logger.log:
            format: "Water total reset to %.1f liters"
            args: ['new_total']
    
    # Reset pump runtime counters
    - service: reset_pump_runtime
      then:
        - globals.set:
            id: total_pump_runtime
            value: '0'
        - logger.log: "Pump runtime counter reset"
    
    # Manual leak alert clear
    - service: clear_leak_alert
      then:
        - logger.log: "Leak alert manually cleared"
```

